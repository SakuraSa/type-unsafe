/*
 HOCON
 */

options {
    // DEBUG_PARSER=true;
    // DEBUG_TOKEN_MANAGER=true;
    ERROR_REPORTING = true;
    JAVA_UNICODE_ESCAPE = true;
    UNICODE_INPUT = true;
}

PARSER_BEGIN(HoconParser)

package com.github.sakurasa.hocon;

import java.io.*;
import java.util.*;
import java.math.*;

public class HoconParser {

    /**
     * Constructor with String.
     * @param input string
     */
	public HoconParser(String input) {
        this(new StringReader(input));
    }
}

PARSER_END(HoconParser)

// Ignore comments
SKIP: {
	<C_SINGLE_COMMENT: "//" (~["\n","\r","\f"])*>
    | <C_MULTILINE_COMMENT: "/*" (~[])* "*/">
    | <SH_SINGLE_COMMENT: "#" (~["\n","\r","\f"])*>
    | <WHITESPACE: " " | "\t">
    | <WHITESEP: ";">
}

<DEFAULT> SKIP: {
    <EOL: "\n" | "\r" | "\f">
}

TOKEN: {
    <INCLUDE: "include">
    | <NULL: "null">
    | <TRUE: "true">
    | <FALSE: "false">
    | <REF_LEAD: "$">
    | <COMMA: ",">
    | <EQUAL: [":", "="]>
    | <BRACE_OPEN: "{">
    | <BRACE_CLOSE: "}">
    | <BRACKET_OPEN: "[">
    | <BRACKET_CLOSE: "]">
    | <PLUS: "+" >
    | <MINUS: "-" >
}

TOKEN: {
    <ECHAR: "\\" ( "t"|"b"|"n"|"r"|"f"|"\\"|"\""|"'") >
    | < #QUOTE_3D: "\"\"\"">
    | < #QUOTE_3S: "'''">
    | < STRING_LITERAL1:
          // Single quoted string
          "'" ( (~["'","\\","\n","\r"]) | <ECHAR> )* "'" >
    | < STRING_LITERAL2:
        // Double quoted string
          "\"" ( (~["\"","\\","\n","\r"]) | <ECHAR> )* "\"" >
    | < STRING_LITERAL_LONG1:
         <QUOTE_3S>
          ( ("'" | "''")? (~["'","\\"] | <ECHAR> ))*
         <QUOTE_3S> >
    | < STRING_LITERAL_LONG2:
         <QUOTE_3D>
          ( ("\"" | "\"\"")? (~["\"","\\"] | <ECHAR> ))*
         <QUOTE_3D> >
    | < STRING_NAKED:
        (~["[", "]", "{", "}", ",", ":", "=", "$", "^", "\"",
           "'", "<", ">", "\\", "/", "`", "\n", "\t", "\r",
           "\f", " ", "#", ";"])+>
}

String parseNakedString(): {
    Token t;
}{
    t = <STRING_NAKED>
    { return t.image; }
}

String parseString(): {
    Token t;
}{
    (
        t = <STRING_LITERAL1>
        { return StringUtil.unescapeJsonString(t.image, 1); }
    ) | (
        t = <STRING_LITERAL2>
        { return StringUtil.unescapeJsonString(t.image, 1); }
    ) | (
        t = <STRING_LITERAL_LONG1>
        { return StringUtil.unescapeJsonString(t.image, 3); }
    ) | (
        t = <STRING_LITERAL_LONG2>
        { return StringUtil.unescapeJsonString(t.image, 3); }
    ) | (
        t = <STRING_NAKED>
        { return StringUtil.unescapeJsonString(t.image, 0); }
    )
}

List<Object> parseList(): {
    ArrayList<Object> list = new ArrayList<>();
    Object value = null;
}{
    <BRACKET_OPEN>
    [
         value = parseValue() { list.add(value); }
         (
            LOOKAHEAD(2)
            ","
            value = parseValue() { list.add(value); }
         )*
         [ "," ]
    ]
    "]"
    { return list; }
}


Map<String, Object> parseObject(): {
    Map<String, Object> obj = new HashMap<>();
    Include include;
}{
    <BRACE_OPEN>
    [
        LOOKAHEAD(<INCLUDE>)
        include = parseInclude()
        {
            List includes = new ArrayList();
            includes.add(include);
            obj.put("__include__", includes);
        }
        | parsePair(obj)
        (
            LOOKAHEAD(2)
            ","
            parsePair(obj)
        )*
        [ "," ]
    ]
    "}"
    { return obj; }
}

void parsePair(Map<String, Object> obj): {
    String key;
    Object value;
}{
    key = parseString()
    (
        (
            <EQUAL>
            value = parseValue()
        ) | (
            value = parseObject()
        )
    )
    { obj.put(key, value); }
}


Object parseValue(): {
    Object value;
}{
    (
        value = parseNull()
        | value = parseBoolean()
        | value = parseString()
        | value = parseList()
        | value = parseObject()
        | value = parseReference()
    ) {
        if ((value instanceof String) && StringUtil.isNumberHeading((String) value)) {
            try {
                return StringUtil.guessNumber((String) value);
            } catch (ParseException ignored) {
            }
        }
        return value;
    }
}

Reference parseReference(): {
    String source;
    Object overwrite = null, tmp = null;
    Token token;
}{
    <REF_LEAD>
    <BRACE_OPEN>
    token = <STRING_NAKED>
    { source = token.image; }
    <BRACE_CLOSE>
    [
        (
            tmp = parseList() {
                if (overwrite == null) {
                    overwrite = tmp;
                } else {
                    ((List)overwrite).addAll((List) tmp);
                }
            }
        )+
        | (
            tmp = parseObject() {
                if (overwrite == null) {
                    overwrite = tmp;
                } else {
                    ((Map)overwrite).putAll((Map) tmp);
                }
            }
        )+
    ]
    { return new Reference(source, overwrite); }
}

Include parseInclude(): {
    String source;
}{
    <INCLUDE>
    source = parseString()
    { return new Include(source); }
}

Paragraph parseParagraph(): {
    String key;
    Object value;
}{
    key = parseString()
    (
        (
            <EQUAL>
            value = parseValue()
        ) | (
            value = parseObject()
        )
    )
    { return new Paragraph(key, value); }
}

Document parseDocument(): {
    Document doc = new Document();
    Paragraph paragraph;
    Include include;
}{
    (
        (
            paragraph = parseParagraph() { doc.lines.add(paragraph); }
            | include = parseInclude() { doc.lines.add(include); }
        )
    )*
    <EOF>
    { return doc; }
}

Void parseNull(): {
}{
    <NULL>
    { return null; }
}

Boolean parseBoolean(): {
    Token t;
}{
    (t = <TRUE> { return Boolean.TRUE; })
    | (t = <FALSE> { return Boolean.FALSE; })
}

Number parseNumber(): {
    String s;
}{
    s = parseNakedString()
    { return StringUtil.guessNumber(s); }
}